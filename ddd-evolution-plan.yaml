# DDD Evolution Plan
# Generated by: /ddd-evolve
# Date: 2026-02-21T00:00:00Z
# Input: [specs/shortfalls.yaml (project: nexus, e2e test)]
# Status: applied
# Reviewed: 2026-02-21T00:00:00Z
# Applied: 2026-02-21T00:00:00Z

meta:
  projects_analyzed: 1
  total_shortfalls_reviewed: 14
  status: applied
  reviewed_at: "2026-02-21T00:00:00Z"
  applied_at: "2026-02-21T00:00:00Z"
  verdicts:
    REAL_GAP: 2
    ENHANCEMENT: 5
    VAGUE: 0
    ALREADY_POSSIBLE: 1
    BY_DESIGN: 3
    PROJECT_SPECIFIC: 1

# ──────────────────────────────────────────────
# TIER 1: Real gaps — recommended for action
# These are genuine DDD framework limitations
# ──────────────────────────────────────────────
real_gaps:
  - id: "RG-001"
    shortfall: "Cache node is read-through only — no 'set' or 'invalidate' operations"
    verdict: REAL_GAP
    source_entries:
      - "workarounds[4]: settings/update-settings process-iJ4gM9xA (cache invalidate)"
      - "workarounds[5]: settings/get-settings process-cD7aG3rU (cache write-through)"
    evidence:
      frequency: 1
      projects: ["nexus"]
      max_severity: medium
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      The cache node currently only supports a hit/miss read-through pattern. Two of the
      three standard cache patterns — write-through (explicit set) and cache invalidation
      (delete on write) — require process node workarounds. This forces every project that
      uses caching beyond simple reads to fall back to unstructured process nodes, losing
      the spec's ability to document cache behavior. The shortfall report's top
      recommendation specifically calls this out, and it appeared as two separate
      workarounds in a single project — strong signal that it's a recurring pattern.
    recommendation:
      action: ADD_FIELD
      scope: "Add 'operation' field to cache node: 'check' (existing hit/miss behavior),
              'set' (explicit write, requires 'value' field), 'invalidate' (delete key).
              'check' remains the default for backwards compatibility. The 'set' and
              'invalidate' operations use a single unnamed output (no branching)."
      affects:
        spec: true
        commands: true
        tool: true
        validator: true
      effort: small
      risk: low
      breaking: false
    decision: approve

  - id: "RG-002"
    shortfall: "Collection node missing 'first' / 'take(n)' operation"
    verdict: REAL_GAP
    source_entries:
      - "workarounds[2]: editorial/assign-reviewer process-t4k3frst (take first element)"
    evidence:
      frequency: 1
      projects: ["nexus"]
      max_severity: medium
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      Collection supports 8 operations (filter, sort, deduplicate, merge, group_by,
      aggregate, reduce, flatten) but misses the most basic list operation: taking the
      first N elements. The typical pattern is sort → take(1) to get the top result,
      but the second step requires a process node. This is a fundamental collection
      operation — every language's standard library includes it (Array.slice, List.take,
      LINQ.First). The collection node should handle this natively rather than forcing
      a process node for element extraction.
    recommendation:
      action: ADD_FIELD
      scope: "Add 'first' and 'last' operations to collection node. 'first' takes
              optional 'count' field (default 1). When count=1, output is a single
              element (not array). When count>1, output is an array. Same for 'last'.
              Both use existing 'result'/'empty' sourceHandles."
      affects:
        spec: true
        commands: true
        tool: true
        validator: true
      effort: small
      risk: low
      breaking: false
    decision: approve

# ──────────────────────────────────────────────
# TIER 2: Enhancements — nice to have
# Valid improvements with adequate workarounds
# ──────────────────────────────────────────────
enhancements:
  - id: "EN-001"
    shortfall: "Delay node used as rate limiter — cannot track request counts, enforce per-client limits, or return 429"
    verdict: ENHANCEMENT
    source_entries:
      - "inadequate_existing_nodes[0]: delay (publishing/publish-to-social, ingestion/scrape-web-content)"
    evidence:
      frequency: 1
      projects: ["nexus"]
      max_severity: medium
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      Rate limiting is a legitimate cross-cutting concern, but adding a full rate_limiter
      node type (window_ms, max_requests, key_by, on_exceeded) is heavy for a single
      project occurrence. The delay node is intentionally simple — a dumb wait. Rate
      limiting is better expressed as a cross-cutting pattern in architecture.yaml or as
      infrastructure configuration (nginx/API gateway level), not as a flow node. The
      workaround is lossy, but the proposed solution overfits to one pattern.
    recommendation:
      action: "Consider adding a 'rate_limit' field to trigger nodes (not a separate node)
               with window_ms, max_requests, and on_exceeded behavior. This handles the
               most common case (per-endpoint rate limiting) without adding a new node type.
               Alternatively, document rate limiting as a cross_cutting_pattern example in
               the architecture template."
      effort: medium
    decision: approve

  - id: "EN-002"
    shortfall: "Webhook trigger missing inline signature_validation field"
    verdict: ENHANCEMENT
    source_entries:
      - "missing_spec_fields[0]: trigger > webhook > signature_validation"
    evidence:
      frequency: 1
      projects: ["nexus"]
      max_severity: low
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      The workaround (crypto verify node as first step after webhook trigger) works
      correctly and preserves design intent. The proposed inline field (algorithm,
      key_source, header_name) would reduce verbosity by one node, but webhook
      signature validation is a narrow use case. The current pattern (trigger → crypto
      verify → continue) is explicit and readable. The benefit is marginal.
    recommendation:
      action: "Add optional 'signature' field to trigger spec for webhook triggers:
               { algorithm, key_source, header_name }. Sugar that compiles to a crypto
               verify node during implementation. Low priority."
      effort: small
    decision: approve

  - id: "EN-003"
    shortfall: "Transform node limited to schema-to-schema field_mappings — cannot do freeform reshaping"
    verdict: ENHANCEMENT
    source_entries:
      - "workarounds[1]: editorial/get-review-stats process-f0rm4tst (format aggregates to response shape)"
    evidence:
      frequency: 1
      projects: ["nexus"]
      max_severity: medium
      specificity: moderate
      workaround_quality: lossy_workaround
    analysis: |
      Transform node requires input_schema, output_schema, and field_mappings — structured
      and precise. The shortfall asks for freeform expressions to reshape arbitrary data,
      which blurs the line between transform (declarative) and process (imperative). The
      proposal is valid but moderate in specificity — "freeform field expressions" needs
      definition. However, response formatting (aggregates → API response shape) is a
      common pattern that currently always falls to process nodes. The shortfall itself
      notes this could be legitimate business_logic process usage.
    recommendation:
      action: "Consider adding an 'expressions' mode to transform that allows computed
               fields (e.g., field_mappings with expressions like '$.items.length' or
               'Math.round($.avg_score * 100)'). This would cover the response-shaping
               pattern while keeping transform declarative. Medium priority."
      effort: medium
    decision: approve

  - id: "EN-004"
    shortfall: "UI specs cannot express drag-drop reorder interaction on item-list/card-grid"
    verdict: ENHANCEMENT
    source_entries:
      - "ui_shortfalls > interaction_gaps[0]: drag-drop-reorder (editorial-queue)"
    evidence:
      frequency: 1
      projects: ["nexus"]
      max_severity: medium
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      DDD UI specs describe layout and data binding but not interaction patterns. Drag-drop
      reorder is a common UI pattern (kanban boards, priority queues, playlist ordering).
      The proposal to add an 'interactions' field to list/grid components with supported
      patterns (reorder, drag-drop, inline-edit, bulk-select) is clean and extensible.
      This would benefit many project types beyond Nexus.
    recommendation:
      action: "Add optional 'interactions' array field to item-list and card-grid components.
               Supported values: 'reorder' (drag-drop reorder with associated update flow),
               'bulk-select' (checkbox selection with bulk action bar),
               'inline-edit' (click-to-edit fields).
               Each interaction specifies the backend flow to call on the action."
      effort: small
    decision: approve

  - id: "EN-005"
    shortfall: "UI specs cannot express inline-edit on detail-card fields"
    verdict: ENHANCEMENT
    source_entries:
      - "ui_shortfalls > interaction_gaps[1]: inline-edit (content-detail, general-settings)"
    evidence:
      frequency: 1
      projects: ["nexus"]
      max_severity: medium
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      Inline editing (click-to-edit a field in place) is a common UI pattern for detail
      pages and settings. The proposal to add 'editable: true' on detail-card fields with
      an update flow reference is minimal and clean. Related to EN-004 — both address
      the same underlying gap: UI specs lack interaction pattern vocabulary.
    recommendation:
      action: "Add optional 'editable' field to detail-card field definitions:
               { editable: true, update_flow: 'domain/flow-id', field_name: 'name' }.
               Can be combined with EN-004 as a unified 'interactions' system."
      effort: small
    decision: approve

# ──────────────────────────────────────────────
# TIER 3: Not actionable
# Shortfalls that don't warrant changes
# ──────────────────────────────────────────────
not_actionable:
  - id: "NA-001"
    shortfall: "Crypto node missing decrypt operation"
    verdict: ALREADY_POSSIBLE
    source_entries:
      - "inadequate_existing_nodes[1]: crypto (users/manage-api-keys)"
    reason: |
      The DDD Usage Guide already lists decrypt as a first-class crypto operation:
      'encrypt' | 'decrypt' | 'hash' | 'sign' | 'verify' | 'generate_key'.
      This shortfall is a false report — the /ddd-create agent incorrectly stated
      decrypt was missing when generating the Nexus project. The crypto node already
      supports decrypt. No framework change needed. The shortfall template compliance
      check in /ddd-create should be updated to cross-reference the Usage Guide before
      reporting inadequate nodes.
    decision: accept_verdict

  - id: "NA-002"
    shortfall: "JWT generation requires process node instead of crypto node"
    verdict: BY_DESIGN
    source_entries:
      - "workarounds[0]: users/login-user process-Qd3nBx9F"
    reason: |
      JWT generation (base64url header + payload, then sign) is a specific authentication
      primitive that goes beyond generic cryptographic signing. The shortfall itself
      acknowledges this: "accept that JWT generation is business logic best left as a
      process node." Process nodes exist precisely for domain-specific business logic
      that doesn't generalize. Adding jwt_sign to crypto would set a precedent for adding
      every auth-specific operation (SAML, PASETO, API key generation, etc.). The current
      design is intentional — crypto handles primitives, process handles compositions.
    decision: accept_verdict

  - id: "NA-003"
    shortfall: "Escalate review to senior editor requires process node"
    verdict: BY_DESIGN
    source_entries:
      - "workarounds[3]: editorial/review-content process-3sc4l8te"
    reason: |
      The shortfall itself states: "Legitimate business_logic — no change needed."
      This is a multi-step domain operation (find available senior editor + reassign
      content + notify) that combines data lookup, business rules, and side effects.
      Process nodes are designed for exactly this. Not every operation needs a structured
      node type — that's the entire purpose of process nodes.
    decision: accept_verdict

  - id: "NA-004"
    shortfall: "Time-bucketed aggregation requires process node"
    verdict: BY_DESIGN
    source_entries:
      - "workarounds[6]: analytics/query-analytics process-Bv6jNr3S"
    reason: |
      Time-bucketed aggregation with configurable granularity involves timezone handling,
      bucket boundary calculations, empty-bucket filling, and metric-specific rollup
      logic. This is genuinely complex analytics business logic. The collection aggregate
      node handles simple operations (count, sum, avg) — adding time_field/granularity
      would be insufficient for real-world use cases and would bloat the node spec.
      The shortfall itself notes: "accept this as business_logic." Process node is correct.
    decision: accept_verdict

  - id: "NA-005"
    shortfall: "Realtime collaborative editing UI patterns not expressible"
    verdict: PROJECT_SPECIFIC
    source_entries:
      - "ui_shortfalls > interaction_gaps[2]: realtime-collaborative-editing (review-panel)"
    reason: |
      Realtime collaborative editing (cursor presence, live edits, conflict resolution)
      is an extremely specialized UI pattern. The vast majority of DDD projects will
      never need it. Adding a 'collaboration' section to page specs would add complexity
      for a niche use case. Projects that need collaborative editing (like Google Docs-
      style interfaces) have unique requirements that don't generalize to a spec format.
      This is better handled as implementation-specific code documented via /ddd-reflect.
    decision: accept_verdict

  - id: "NA-006"
    shortfall: "48 flows to 12 pages ratio (4:1)"
    verdict: BY_DESIGN
    source_entries:
      - "pillar_balance > imbalance_warnings[0]"
    reason: |
      The shortfall report itself explains this is acceptable: "many flows are internal
      event handlers, cron jobs, and agent pipelines that have no direct UI surface."
      A 4:1 ratio is normal for event-driven architectures with background processing.
      No framework change needed — the pillar balance section correctly flagged and
      dismissed it.
    decision: accept_verdict

# ──────────────────────────────────────────────
# Execution order (for approved items only)
# ──────────────────────────────────────────────
recommended_order:
  - phase: 1
    ids: ["RG-001", "RG-002"]
    rationale: "Both are small-effort additions to existing node types (cache and
                collection). No dependencies between them. Highest impact — these
                are the only REAL_GAP items."
  - phase: 2
    ids: ["EN-004", "EN-005"]
    rationale: "UI interaction patterns — EN-004 (drag-drop/interactions field) and
                EN-005 (inline-edit) are related and should be designed together as
                a unified interaction system. Small effort."
  - phase: 3
    ids: ["EN-001", "EN-002", "EN-003"]
    rationale: "Lower-priority enhancements with adequate workarounds. EN-001 (rate
                limiting) and EN-003 (transform expressions) need more design work.
                EN-002 (webhook signature) is low priority."

# ──────────────────────────────────────────────
# Bug found in /ddd-create shortfall generation
# ──────────────────────────────────────────────
bugs_found:
  - id: "BUG-001"
    description: "The Nexus shortfall report incorrectly claims crypto is missing 'decrypt'
                  operation, but the DDD Usage Guide already defines it as a first-class
                  operation: 'encrypt' | 'decrypt' | 'hash' | 'sign' | 'verify' | 'generate_key'.
                  The /ddd-create --shortfalls agent should cross-reference the Usage Guide
                  before reporting inadequate_existing_nodes."
    affects: "/ddd-create command (claude-commands repo)"
    severity: low
