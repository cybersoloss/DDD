# DDD Evolution Plan
# Generated by: /ddd-evolve
# Date: 2026-02-23T12:00:00Z
# Input: [~/dev/vantage-test/specs/shortfalls.yaml (project: vantage)]
# Status: pending_review

meta:
  projects_analyzed: 1
  total_shortfalls_reviewed: 26
  note: >
    websocket-broadcast gap also found in gtdos shortfalls and referenced
    in DDD-USAGE-GUIDE.md example shortfalls (line 3642) — treating as systemic
    (2+ project occurrences).
  status: pending_review
  verdicts:
    REAL_GAP: 8
    ENHANCEMENT: 18
    VAGUE: 0
    ALREADY_POSSIBLE: 0
    BY_DESIGN: 0
    PROJECT_SPECIFIC: 0
  pillar_distribution:
    logic: 5       # websocket-broadcast, batch sub_flow_ref, agent_loop memory config, circuit_break config, loop break_condition
    data: 0
    interface: 3   # form repeating groups, map-view component, form options_depends_on
    infrastructure: 0
    cross_cutting: 8  # flow auth, ws trigger config, rate limiting, logging, monitoring, layer gaps, SLA

# ──────────────────────────────────────────────
# TIER 1: Real gaps — recommended for action
# ──────────────────────────────────────────────
real_gaps:
  - id: "RG-001"
    shortfall: "No websocket-broadcast node type for server-push fan-out"
    verdict: REAL_GAP
    evidence:
      frequency: 3
      projects: ["gtdos (shortfalls.yaml line 3642 in Usage Guide)", "vantage (2 flows)", "nexus (streaming flows)"]
      max_severity: high
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      The ws trigger handles incoming WebSocket connections, but there is no
      structured node for pushing data FROM a flow TO connected clients. Two
      Vantage flows (stream-shipment-position, stream-live-metrics) require
      process nodes with free-text descriptions to express Socket.io room
      broadcasts. This makes WebSocket server-push logic invisible on the
      flow canvas — breaking DDD's visual completeness promise for realtime
      applications. The same gap appeared in gtdos and is referenced as a
      known shortfall in the Usage Guide itself (line 3642), making this
      a systemic issue across multiple real-world projects.
    recommendation:
      action: ADD_NODE_TYPE
      pillar: logic
      scope: >
        Add websocket_broadcast node type with fields:
        channel (string — Socket.io room or topic name),
        event_name (string — WS event identifier),
        payload (expression — data to broadcast),
        include_sender (boolean — whether to echo to sender, default false).
        Single output handle: done.
      affects:
        spec: true
        commands: true
        tool: true
        validator: true
      effort: medium
      risk: low
      breaking: false
    decision: null

  - id: "RG-002"
    shortfall: "batch node cannot reference a sub_flow as its per-item operation"
    verdict: REAL_GAP
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: high
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      The batch node processes a collection in chunks but its per-item operation
      can only be described as a service_call or in free text. Vantage's
      forecasting/run-daily-forecast and batch-generate-forecasts need to call
      a sub_flow per item (generate-ai-forecast) — instead they use process nodes
      to describe the per-item logic. Adding sub_flow_ref as an alternative to
      service_call on the batch node would make complex per-item processing
      fully traceable through the spec graph.
    recommendation:
      action: ADD_FIELD
      pillar: logic
      scope: >
        Add sub_flow_ref field to batch node (mutually exclusive with service_call):
        sub_flow_ref: "domain/flow-id" — calls that flow for each item in the batch.
        The referenced flow must have a contract section with inputs/outputs.
      affects:
        spec: true
        commands: true
        tool: true
        validator: false
      effort: small
      risk: low
      breaking: false
    decision: null

  - id: "RG-003"
    shortfall: "No flow-level auth declaration — authentication requirements live only in pages.yaml"
    verdict: REAL_GAP
    evidence:
      frequency: 2
      projects: ["vantage", "gtdos (architecture.yaml workaround pattern)"]
      max_severity: high
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      Flow specs have no field for declaring authentication requirements or
      permitted roles. Auth is defined in pages.yaml (UI level) and
      architecture.yaml (convention level) but never at the flow/API level.
      This creates a gap: /ddd-implement cannot generate auth middleware per
      flow because there is no spec field to read. The cross_cutting_gaps
      auth entry (JWT requirement on all HTTP flows except register/login)
      and the missing_spec_fields auth_required entry describe the same
      underlying problem. Auth is a first-class concern that belongs in
      the flow spec, not in documentation conventions.
    recommendation:
      action: ADD_FIELD
      pillar: cross_cutting
      scope: >
        Add auth field to flow metadata: {required: boolean, roles: string[],
        strategy: 'jwt' | 'api_key' | 'none'}.
        /ddd-implement reads this to generate middleware.
        /ddd-create quality check: HTTP-triggered flows without auth field
        should emit a warning (not an error — internal/cron flows are exempt).
      affects:
        spec: true
        commands: true
        tool: false
        validator: true
      effort: small
      risk: low
      breaking: false
    decision: null

  - id: "RG-004"
    shortfall: "Form specs cannot express repeating field groups (sub-tables / line items)"
    verdict: REAL_GAP
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: high
      specificity: specific
      workaround_quality: critical_gap
    analysis: |
      Purchase order line items are a canonical UI pattern (also: invoice lines,
      BOM rows, expense items, product variants) — a dynamic list of structured
      rows inside a form. Vantage's create-edit-order page requires exactly this,
      but the form field type system has no way to express it. The workaround used
      is textarea with JSON, which loses all type safety, validation, and UX quality.
      This is arguably the worst workaround in the report — it makes the spec
      actively misleading about what the UI actually looks like. Any business
      application managing records with child line items hits this gap.
    recommendation:
      action: ADD_FIELD
      pillar: interface
      scope: >
        Add repeating_group form field type:
        {type: 'repeating_group', name: string, label: string,
        columns: [{name, type, label, required, options?}],
        min_rows: number, max_rows: number,
        add_label: string, remove_label: string}.
        Renders as an editable grid with add/remove row controls.
        /ddd-implement generates a sub-table component with row management.
      affects:
        spec: true
        commands: true
        tool: true
        validator: false
      effort: medium
      risk: low
      breaking: false
    decision: null

  - id: "RG-005"
    shortfall: "No map-view component type — chart is being stretched to render geographic maps"
    verdict: REAL_GAP
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: high
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      The chart component is used with chart_type: map as a workaround for
      geographic map visualization. This conflates data visualization (chart)
      with geographic mapping (map) — they are fundamentally different paradigms.
      chart has no fields for center coordinates, zoom level, marker configuration,
      route polylines, or realtime position updates. Any logistics, delivery,
      field service, or location-aware application faces this gap. Two pages in
      Vantage require geographic mapping (shipment-tracking live position,
      warehouse map). Using chart for maps produces technically valid YAML
      that misleads /ddd-implement about the component to generate.
    recommendation:
      action: ADD_NODE_TYPE
      pillar: interface
      scope: >
        Add map-view component type to UI spec with fields:
        data_source (flow ref), center_lat/center_lng (initial center),
        zoom (initial zoom level), markers (array — {lat_field, lng_field,
        label_field, color_field, click_action}), routes (array — {points_field,
        color, width}), realtime (boolean — enables live marker updates via WS).
        Also: clean up chart component by removing chart_type: map — it should
        not be used for geographic data.
      affects:
        spec: true
        commands: true
        tool: true
        validator: false
      effort: medium
      risk: low
      breaking: false
    decision: null

  - id: "RG-006"
    shortfall: "agent_loop vector_store memory type has no configuration fields"
    verdict: REAL_GAP
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      The agent_loop memory types (conversation_history, vector_store, key_value)
      are defined at name/description level only. vector_store in particular
      requires configuration: embedding model, similarity threshold, max results,
      and namespace. Without these fields, the spec cannot drive /ddd-implement
      to generate correct vector store initialization code. Two AI-heavy flows
      (suppliers/trigger-risk-review, forecasting/generate-ai-forecast) use
      vector_store memory but the spec is incomplete at the point where
      implementation detail is most needed.
    recommendation:
      action: ADD_FIELD
      pillar: logic
      scope: >
        Extend agent_loop memory entry for type: vector_store with:
        embedding_model (string, e.g., "text-embedding-3-small"),
        similarity_threshold (number, 0-1),
        max_results (number),
        namespace (string, optional — for multi-tenant isolation).
      affects:
        spec: true
        commands: true
        tool: false
        validator: false
      effort: small
      risk: low
      breaking: false
    decision: null

  - id: "RG-007"
    shortfall: "WebSocket trigger (ws) has no connection_config for auth and access control"
    verdict: REAL_GAP
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      HTTP triggers have rate_limit, signature validation, and filter fields for
      access control. WebSocket triggers have none of these — no authentication
      requirement, no connection rate limiting, no heartbeat or reconnect config.
      This is a security gap: ws triggers that should require JWT authentication
      can only document this in architecture.yaml free text. /ddd-implement cannot
      generate WebSocket auth middleware without a structured field to read.
      Two Vantage flows (analytics/stream-live-metrics, logistics/track-shipment-live)
      require authenticated WebSocket connections.
    recommendation:
      action: ADD_FIELD
      pillar: cross_cutting
      scope: >
        Add connection_config to ws trigger: {auth_required: boolean,
        auth_strategy: 'jwt' | 'api_key' | 'none',
        heartbeat_ms: number (default: 30000),
        max_connections_per_client: number (optional),
        reconnect: boolean (default: true)}.
      affects:
        spec: true
        commands: true
        tool: false
        validator: false
      effort: small
      risk: low
      breaking: false
    decision: null

  - id: "RG-008"
    shortfall: "circuit_break connection behavior has no configuration fields"
    verdict: REAL_GAP
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: lossy_workaround
    analysis: |
      The connection behavior: circuit_break is a documented option but functions
      as a label only — there is no circuit_break_config field to declare threshold,
      recovery timeout, or half-open behavior. A circuit breaker without configuration
      is not a circuit breaker — it is an annotation that /ddd-implement cannot
      act on. logistics/retry-carrier-api uses a manual loop + delay sub_flow as
      a workaround because the structural circuit breaker cannot be configured.
      This is particularly wasteful given that the connection behavior is already
      enumerated in the spec.
    recommendation:
      action: ADD_FIELD
      pillar: logic
      scope: >
        Add circuit_break_config to connections that use behavior: circuit_break:
        {failure_threshold: number (failures before opening),
        recovery_timeout_ms: number (time in open state before half-open),
        half_open_max_calls: number (test calls in half-open state)}.
        /ddd-implement reads this to generate opossum or equivalent circuit breaker.
      affects:
        spec: true
        commands: true
        tool: false
        validator: false
      effort: small
      risk: low
      breaking: false
    decision: null

# ──────────────────────────────────────────────
# TIER 2: Enhancements — nice to have
# ──────────────────────────────────────────────
enhancements:
  - id: "EN-001"
    shortfall: "loop break_condition is free-text — no structured condition type"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      Free-text break_condition strings work — the loop still terminates correctly.
      The limitation is that static analysis and visualization cannot inspect the
      condition. A structured break_condition type would enable the DDD Tool to
      display termination logic visually and allow validators to catch unreachable loops.
    recommendation:
      action: ADD_FIELD
      pillar: logic
      scope: >
        Support structured break_condition alongside existing free-text string:
        {type: 'expression' | 'field_check' | 'event',
        field?: string, operator?: 'eq|gt|gte|lt|lte|in', value?: any, event?: string}
    decision: null

  - id: "EN-002"
    shortfall: "service_call has no fallback value for non-critical enrichment failures"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: low
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      Error terminal is a valid path for failed service_calls. A fallback field
      would simplify non-critical enrichment flows (supplier data enrichment)
      that should degrade gracefully without routing to an error terminal.
    recommendation:
      action: ADD_FIELD
      pillar: logic
      scope: "Add fallback: {value: any, log: boolean} to service_call — when set, failure uses fallback value instead of routing to error handle"
    decision: null

  - id: "EN-003"
    shortfall: "cache node has no ttl_jitter for thundering herd prevention"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: low
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      Delay node is an adequate workaround for TTL jitter. A ttl_jitter_ms field
      on the cache set operation would be more declarative and semantically correct.
    recommendation:
      action: ADD_FIELD
      pillar: logic
      scope: "Add ttl_jitter_ms: number to cache set operation — randomizes TTL between ttl_ms and ttl_ms + ttl_jitter_ms"
    decision: null

  - id: "EN-004"
    shortfall: "event nodes have no correlation_id field for distributed tracing"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: low
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      Including correlation data in event payload is an adequate workaround.
      A first-class correlation_id field would standardize distributed tracing
      patterns and allow /ddd-implement to wire tracing automatically.
    recommendation:
      action: ADD_FIELD
      pillar: logic
      scope: "Add correlation_id: string (expression) to event node — propagated automatically across domain boundaries"
    decision: null

  - id: "EN-005"
    shortfall: "domain spec has no SLA configuration field"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: moderate
      workaround_quality: adequate_workaround
    analysis: |
      Storing SLA thresholds in SystemConfig (database) is an adequate workaround.
      A domain-level sla_config would make performance contracts visible at L2
      and enable /ddd-scaffold to generate latency monitoring hooks automatically.
    recommendation:
      action: ADD_FIELD
      pillar: cross_cutting
      scope: "Add sla_config to domain.yaml: {max_latency_ms: number, alert_threshold_ms: number, on_breach: event_name}"
    decision: null

  - id: "EN-006"
    shortfall: "No fan-in correlation gate for multi-event join patterns"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: low
      specificity: moderate
      workaround_quality: adequate_workaround
    analysis: |
      event_group trigger partially addresses this. Adding a correlation_key to
      event_group triggers would allow expressing "wait for stock.depleted AND
      order.cancelled for the same sku" without a custom process node.
    recommendation:
      action: ADD_FIELD
      pillar: logic
      scope: "Extend event_group trigger with correlation_key field: groups matching events by a shared payload field (e.g., sku_id, order_id)"
    decision: null

  - id: "EN-007"
    shortfall: "L1 canvas does not show WebSocket connection topology"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      WebSocket endpoints (ws trigger flows) and their frontend consumers are
      invisible at L1. The socket.io realtime layer is a significant architectural
      component for realtime applications but leaves no trace at system level.
    recommendation:
      action: ADD_LAYER_ELEMENT
      pillar: cross_cutting
      scope: "Add ws_topology to system.yaml: [{channel, producer_flow, consumer_pages[]}] — rendered as realtime arrows at L1"
    decision: null

  - id: "EN-008"
    shortfall: "L1 canvas does not show BullMQ queue topology"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      Which flows produce jobs to which queues, and which worker services consume
      which queues, is invisible at L1. The queue-worker service block gives no
      breakdown of queue membership.
    recommendation:
      action: ADD_LAYER_ELEMENT
      pillar: cross_cutting
      scope: "Extend infrastructure.yaml worker services with queues: [{name, consumer_flows[], producer_flows[]}] — shown at L1 as queue topology"
    decision: null

  - id: "EN-009"
    shortfall: "L2 canvas does not show agent memory stores alongside database/cache stores"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      When a domain uses agent_loop with vector_store or key_value memory, those
      memory stores are invisible at L2. They should appear as domain-level
      components alongside database schemas and cache references.
    recommendation:
      action: ADD_LAYER_ELEMENT
      pillar: cross_cutting
      scope: "Add memory_stores to domain.yaml: [{name, type: vector_store|key_value|conversation_history, used_by: flow_ids[]}] — shown at L2 as memory topology nodes"
    decision: null

  - id: "EN-010"
    shortfall: "No timeline component type for ordered event sequences"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      item-list is used for shipment event history and supplier activity logs.
      A timeline component would express the temporal relationship between events
      with step indicators and time gaps — important for logistics visibility pages.
    recommendation:
      action: ADD_NODE_TYPE
      pillar: interface
      scope: >
        Add timeline UI component type:
        {data_source, timestamp_field, title_field, status_field,
        icon_field (optional), color_when (conditions → color),
        direction: 'vertical' | 'horizontal'}
    decision: null

  - id: "EN-011"
    shortfall: "item-list has no realtime_insert_position for WebSocket-driven item prepending"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      When a list has a realtime data source (WebSocket), there is no way to
      declare whether new items should be prepended (newest first) or appended
      (oldest first). This affects every live-updating list in realtime applications.
    recommendation:
      action: ADD_FIELD
      pillar: interface
      scope: "Add realtime_insert_position: 'top' | 'bottom' to item-list sections that have a realtime data source"
    decision: null

  - id: "EN-012"
    shortfall: "Form fields have no options_depends_on for dynamic cross-field option filtering"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      The supplier → currency dependency in create-edit-order (supplier's preferred
      currency pre-selects the currency dropdown) and similar dynamic form patterns
      are common in business applications. visible_when handles conditional visibility
      but not dynamic option sets.
    recommendation:
      action: ADD_FIELD
      pillar: interface
      scope: >
        Add options_depends_on to form field:
        {field: string, transform: 'filter' | 'set_default' | 'set_options',
        source_field: string} — dynamically filters or updates options based on
        the value of another field in the same form.
    decision: null

  - id: "EN-013"
    shortfall: "No multi-step wizard form type for complex multi-stage inputs"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      Supplier onboarding (12 fields across 3 logical sections) and similar
      complex forms would benefit from a guided wizard with per-step validation.
      Currently expressed as a single long form with all fields.
    recommendation:
      action: ADD_FIELD
      pillar: interface
      scope: >
        Add wizard form type alongside regular form:
        {type: 'wizard', steps: [{id, title, description, fields: string[]}],
        show_progress: boolean, allow_skip: boolean} — renders with Next/Back
        navigation and per-step validation.
    decision: null

  - id: "EN-014"
    shortfall: "No realtime_behavior spec for how UI reacts to WebSocket data updates"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      The page state realtime field declares a subscription but not the UI
      behavior on data arrival (highlight row, prepend vs append, badge count).
      This forces /ddd-implement to make arbitrary choices about realtime UX.
    recommendation:
      action: ADD_FIELD
      pillar: interface
      scope: >
        Add realtime_behavior to sections with realtime data_source:
        {on_new_item: 'prepend' | 'append' | 'refresh',
        on_update: 'highlight' | 'silent' | 'badge_count',
        highlight_duration_ms: number}
    decision: null

  - id: "EN-015"
    shortfall: "HTTP trigger rate_limit has no tier-based limits (per role/user-class)"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: medium
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      The current rate_limit is a single limit per endpoint. Role-based limits
      (admin: 1000/min, viewer: 100/min) are common in multi-tier SaaS applications
      but cannot be expressed without a single global limit per trigger.
    recommendation:
      action: ADD_FIELD
      pillar: cross_cutting
      scope: "Extend trigger rate_limit with tier_limits: [{role: string, max_requests: number, window_ms: number}] — role-specific overrides"
    decision: null

  - id: "EN-016"
    shortfall: "No per-node structured logging declaration"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: low
      specificity: moderate
      workaround_quality: adequate_workaround
    analysis: |
      Business events (order approved, supplier flagged) that should emit
      structured log entries with specific fields cannot be declared at spec level.
      /ddd-implement generates uniform logging; selective business event logging
      requires custom code.
    recommendation:
      action: ADD_FIELD
      pillar: cross_cutting
      scope: "Add optional log field to nodes: {level: 'info'|'warn'|'error', fields: string[], condition?: expression}"
    decision: null

  - id: "EN-017"
    shortfall: "No flow-level custom metrics declaration for performance-critical flows"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: low
      specificity: moderate
      workaround_quality: adequate_workaround
    analysis: |
      Performance-critical flows (analytics/get-dashboard-data) cannot declare
      custom Prometheus metrics at spec level. /ddd-scaffold cannot generate
      metric registration without spec guidance.
    recommendation:
      action: ADD_FIELD
      pillar: cross_cutting
      scope: "Add optional metrics to flow metadata: [{name: string, type: counter|gauge|histogram, labels: string[]}]"
    decision: null

  - id: "EN-018"
    shortfall: "L2 does not show BullMQ queue membership for cron/interval flows"
    verdict: ENHANCEMENT
    evidence:
      frequency: 1
      projects: ["vantage"]
      max_severity: low
      specificity: specific
      workaround_quality: adequate_workaround
    analysis: |
      Flows with cron/interval triggers that run in a BullMQ queue (with
      concurrency: 1) don't show their queue membership at L2. Minor visualization gap.
    recommendation:
      action: ADD_LAYER_ELEMENT
      pillar: cross_cutting
      scope: "Add queue field to trigger job_config — shown as a badge at L2 on flows that use the queue-worker"
    decision: null

# ──────────────────────────────────────────────
# Execution order (for approved items only)
# ──────────────────────────────────────────────
recommended_order:
  - phase: 1
    ids: ["RG-003", "RG-006", "RG-007", "RG-008"]
    rationale: >
      Spec-only field additions to existing node/trigger/connection types.
      Low effort, no tool changes required, no breaking changes.
      These close documentation and structural gaps immediately.

  - phase: 2
    ids: ["RG-002", "RG-004", "EN-001", "EN-012"]
    rationale: >
      Field additions that also require command (ddd-create.md) updates
      and minor tool editor changes. Medium effort. RG-002 (batch sub_flow_ref)
      and RG-004 (form repeating groups) are high-value. EN-001 (loop condition)
      and EN-012 (options_depends_on) complement the form improvements.

  - phase: 3
    ids: ["RG-001", "RG-005", "EN-010", "EN-011", "EN-014"]
    rationale: >
      New node types and UI components. Larger scope — requires spec, commands,
      tool, and validator changes. RG-001 (websocket-broadcast) is the most
      impactful item; RG-005 (map-view) follows. Timeline, realtime list,
      and realtime behavior complete the realtime UI story.
